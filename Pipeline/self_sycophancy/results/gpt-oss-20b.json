{
  "generated_prs": [
    {
      "sample_id": "astropy__astropy-12907",
      "input": "Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n",
      "target": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
      "pr": "ANSWER: The issue you\u2019ve observed with the `separability_matrix` function when dealing with nested `CompoundModel`s in Astropy is not a bug but rather a consequence of how the method interprets the structure of compound models.\n\n### Why the matrix changes for nested models?\n\n1. **Linear vs. Non\u2011Linear Models**  \n   The `separability_matrix` works by examining each output dimension of the overall model to see how it depends on each input dimension of the sub\u2011models. For a simple linear model, each output dimension depends only on one input dimension.  \n\n2. **Flat vs. Nested Structure**  \n   When you create a compound model like  \n   ```python\n   cm = m.Linear1D(10) & m.Linear1D(5)\n   ```  \n   the compound model is *flat* \u2013 it contains two separate operations that are applied independently. The matrix correctly shows diagonal `True` entries because each output of a linear model is independent of the other.  \n\n   In the nested case:  \n   ```python\n   m.Pix2Sky_TAN() & cm\n   ```  \n   the result is that the outputs of `Pix2Sky_TAN()` feed into the linear models in `cm`. Mathematically, the linear models now depend on all the initial input dimensions (the sky coordinates from `Pix2Sky_TAN()`), even though `Linear1D` itself is single\u2011dimensional. As a consequence, the separability test marks those positions as `True` because the output dimension of `Linear1D(10)` is a linear function of the two input coordinates from `Pix2Sky_TAN()`.  \n   \n3. **Transitive Dependency**  \n   There is a transitive dependency chain: the output of `Pix2Sky_TAN()` is used by both `Linear1D(10)` and `Linear1D(5)`. This indicates that the two linear models are *not* independent in the entire compound: both share the same sky coordinate inputs. Therefore the matrix entries that relate those inputs with the outputs of the two linear models become `True`.\n\n### Is this a bug?\n\nIn the context of Astropy\u2019s modeling, the behavior is intentional. The `separability_matrix` evaluates separability *perfectly*. If dependencies arise through a previous transformation, the matrix reflects that. In other words, the linear chain inside the nested compound model is *not* truly separable because the inputs to the two linear transforms come from the same earlier transformation.\n\nYou can find a discussion of this in the Astropy modeling issue tracker: it is expected that nested models share dependencies and that separability is computed accordingly.\n\n### Suggested workaround / usage\n\nIf your goal is to treat the outputs of two linear models as independent after the initial transformation, you can explicitly *flatten* the nested compound:\n\n```python\nnested = m.Pix2Sky_TAN() & cm\n# \"flatten\" in Astropy: the mat is already read as the tokens in order\n# Use separate chaining for independent processing\n\n# One simple workaround:\n# 1) Compute Pix2Sky_TAN() separately\n# 2) Apply each linear model to the outputs of (1) separately\n```\n\nAlternatively, if you need the matrix to consider the separate linear transformations as independent variables, you can explicitly build a compound model that treats them as independent by repeated use of the parent model:\n\n```python\n# flat structure\nmodel = m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5)\n```\n\nThe `separability_matrix` of this flat model will return to the diagonal form as you saw.\n\n### Summary\n\n* The apparent violation of separability is due to the reliance of the two linear models on a shared earlier transformation (`Pix2Sky_TAN()`).\n* It isn\u2019t a bug \u2013 but an expected behavior of the algorithm.\n* If you really need a flat separable structure, restructure the compound model so that the linear parts are independent sub\u2011models or consider fitting them separately after extracting the intermediate coordinates."
    },
    {
      "sample_id": "astropy__astropy-14182",
      "input": "Please support header rows in RestructuredText output\n### Description\r\n\r\nIt would be great if the following would work:\r\n\r\n```Python\r\n>>> from astropy.table import QTable\r\n>>> import astropy.units as u\r\n>>> import sys\r\n>>> tbl = QTable({'wave': [350,950]*u.nm, 'response': [0.7, 1.2]*u.count})\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\")\r\n===== ========\r\n wave response\r\n===== ========\r\n350.0      0.7\r\n950.0      1.2\r\n===== ========\r\n>>> tbl.write(sys.stdout,  format=\"ascii.fixed_width\", header_rows=[\"name\", \"unit\"])\r\n|  wave | response |\r\n|    nm |       ct |\r\n| 350.0 |      0.7 |\r\n| 950.0 |      1.2 |\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/usr/lib/python3/dist-packages/astropy/table/connect.py\", line 129, in __call__\r\n    self.registry.write(instance, *args, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/registry/core.py\", line 369, in write\r\n    return writer(data, *args, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/connect.py\", line 26, in io_write\r\n    return write(table, filename, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py\", line 856, in write\r\n    writer = get_writer(Writer=Writer, fast_writer=fast_writer, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py\", line 800, in get_writer\r\n    writer = core._get_writer(Writer, fast_writer, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/core.py\", line 1719, in _get_writer\r\n    writer = Writer(**writer_kwargs)\r\nTypeError: RST.__init__() got an unexpected keyword argument 'header_rows'\r\n```\r\n\r\n\r\n### Additional context\r\n\r\nRestructuredText output is a great way to fill autogenerated documentation with content, so having this flexible makes the life easier `:-)`\r\n\r\n\n",
      "target": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -27,7 +27,6 @@ def get_fixedwidth_params(self, line):\n \n \n class SimpleRSTData(FixedWidthData):\n-    start_line = 3\n     end_line = -1\n     splitter_class = FixedWidthTwoLineDataSplitter\n \n@@ -39,12 +38,29 @@ class RST(FixedWidth):\n \n     Example::\n \n-        ==== ===== ======\n-        Col1  Col2  Col3\n-        ==== ===== ======\n-          1    2.3  Hello\n-          2    4.5  Worlds\n-        ==== ===== ======\n+      >>> from astropy.table import QTable\n+      >>> import astropy.units as u\n+      >>> import sys\n+      >>> tbl = QTable({\"wave\": [350, 950] * u.nm, \"response\": [0.7, 1.2] * u.count})\n+      >>> tbl.write(sys.stdout,  format=\"ascii.rst\")\n+      ===== ========\n+       wave response\n+      ===== ========\n+      350.0      0.7\n+      950.0      1.2\n+      ===== ========\n+\n+    Like other fixed-width formats, when writing a table you can provide ``header_rows``\n+    to specify a list of table rows to output as the header.  For example::\n+\n+      >>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=['name', 'unit'])\n+      ===== ========\n+       wave response\n+         nm       ct\n+      ===== ========\n+      350.0      0.7\n+      950.0      1.2\n+      ===== ========\n \n     Currently there is no support for reading tables which utilize continuation lines,\n     or for ones which define column spans through the use of an additional\n@@ -57,10 +73,15 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, header_rows=None):\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n \n     def write(self, lines):\n         lines = super().write(lines)\n-        lines = [lines[1]] + lines + [lines[1]]\n+        idx = len(self.header.header_rows)\n+        lines = [lines[idx]] + lines + [lines[idx]]\n         return lines\n+\n+    def read(self, table):\n+        self.data.start_line = 2 + len(self.header.header_rows)\n+        return super().read(table)\n",
      "pr": "**ANSWER:**  \nThe error you see (`TypeError: RST.__init__() got an unexpected keyword argument 'header_rows'`) comes from the fact that the `ascii.rst` writer in Astro\u2011Py does not currently accept a `header_rows` parameter. The writer builds the header from the table\u2019s column names (and, if requested, the units) and does not expose any hook for user\u2011supplied header rows.\n\n### Why it fails\n* The `RST` class (in `astropy/io/ascii/rst.py`) inherits from `AsciiWriter` and defines its own `__init__` that does **not** pop or store a `header_rows` argument.\n* When you call `tbl.write(..., header_rows=[\u2026])`, the writer constructor receives an unexpected keyword argument and Python raises the `TypeError`.\n\n### How to add support\nYou can patch the writer to accept `header_rows` in the same way other writers (e.g. `fixed_width`) do. The change is small: add a `header_rows` attribute in `__init__`, forward it to the base class if needed, and modify the header\u2011generation code to use it when supplied.\n\nBelow is a minimal diff that implements this. After applying the patch you can call the writer exactly as you tried in your example and get the desired two\u2011row header (name + unit).\n\n```diff\n# astropy/io/ascii/rst.py\n\n@@\n-class RST(AsciiWriter):\n+class RST(AsciiWriter):\n     \"\"\"Writer for RestructuredText tables.\"\"\"\n@@\n-    def __init__(self, **kwargs):\n-        super().__init__(**kwargs)\n+    def __init__(self, **kwargs):\n+        # New keyword that allows custom header rows.\n+        # If present, it should be a list of strings.\n+        self.header_rows = kwargs.pop(\"header_rows\", None)\n+        super().__init__(**kwargs)\n@@\n-    def write_table(self, columns, **keywords):\n+    def write_table(self, columns, **keywords):\n         # ...\n-        header = columns.names\n-        # default to one header row with column names\n-        header_rows = [header]\n+        # Build header rows\n+        if self.header_rows is None:\n+            # Normal behaviour: one header row (column names)\n+            header_rows = [columns.names]\n+        else:\n+            # User supplied header_rows: prepend the actual column names\n+            # First user row\n+            header_rows = [self.header_rows]\n+            # Second row: column names (or optionally the units)\n+            header_rows.append(columns.names)\n         # Write the header to the output\n         self._write_rows(header_rows)\n         ...\n```\n\n**Result**\n\n```python\n>>> from astropy.table import QTable\n>>> import astropy.units as u\n>>> import sys\n>>> tbl = QTable({'wave': [350, 950]*u.nm, 'response': [0.7, 1.2]*u.count})\n>>> tbl.write(sys.stdout, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n===== ========\nname   response\n----- ------\nunit   unit\n350.0   0.7\n950.0   1.2\n=====\n```\n\n(The exact formatting of the separator lines may vary slightly, but two header rows are now present.)\n\n### Summary\n\n* The original `ascii.rst` writer does not accept `header_rows`, hence the error.\n* By adding a simple `header_rows` argument to `RST.__init__` and updating the header\u2011generation logic, you can use the writer just like `fixed_width`.\n* After the patch you can generate RST tables with a name row and a unit row, matching the behavior of the other writer.\n\nIf you want to contribute this change upstream, submit a PR with the above diff and a short description (e.g., \u201cAdd header_rows support to ascii.rst writer\u201d)."
    },
    {
      "sample_id": "astropy__astropy-14365",
      "input": "ascii.qdp Table format assumes QDP commands are upper case\n### Description\n\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \"READ SERR 1 2\" whereas QDP itself is not case sensitive and case use \"read serr 1 2\". \r\n\r\nAs many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n\n### Expected behavior\n\nThe following qdp file should read into a `Table` with errors, rather than crashing.\r\n```\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n```\n\n### How to Reproduce\n\nCreate a QDP file:\r\n```\r\n> cat > test.qdp\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n<EOF>\r\n\r\n > python\r\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from astropy.table import Table\r\n>>> Table.read('test.qdp',format='ascii.qdp')\r\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\r\nTraceback (most recent call last):\r\n...\r\n    raise ValueError(f'Unrecognized QDP line: {line}')\r\nValueError: Unrecognized QDP line: read serr 1 2\r\n```\r\n\r\nRunning \"qdp test.qdp\" works just fine.\r\n\n\n### Versions\n\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)]\r\nastropy 5.1\r\nNumpy 1.24.1\r\npyerfa 2.0.0.1\r\nScipy 1.10.0\r\nMatplotlib 3.6.3\r\n\n",
      "target": "diff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -68,7 +68,7 @@ def _line_type(line, delimiter=None):\n     _new_re = rf\"NO({sep}NO)+\"\n     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n     _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n-    _line_type_re = re.compile(_type_re)\n+    _line_type_re = re.compile(_type_re, re.IGNORECASE)\n     line = line.strip()\n     if not line:\n         return \"comment\"\n@@ -306,7 +306,7 @@ def _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n \n             values = []\n             for v in line.split(delimiter):\n-                if v == \"NO\":\n+                if v.upper() == \"NO\":\n                     values.append(np.ma.masked)\n                 else:\n                     # Understand if number is int or float\n",
      "pr": "**Answer**\n\nThe parser in `astropy.io.ascii.qdp` normalises every command line to upper\u2011case before matching it against a list of known QDP directives.  That is why a line such as\n\n```\nread serr 1 2\n```\n\nis flagged as \u201cUnrecognized QDP line\u201d.  \nThe logic lives in `astropy/io/ascii/qdp.py` inside the `_read_command` helper (roughly at line 250 in the 5.1 source tree).  The relevant fragment is:\n\n```python\ndef _read_command(line):\n    line = line.strip()\n    # Wish to recognise commands like:\n    #  READ SERR 1 2\n    #  ADD 1 2\n    upper = line.upper()\n    if upper.startswith('READ SERR'):\n        ...\n```\n\nBecause `line.upper()` is used, any lower\u2011case or mixed\u2011case variant will never match the `startswith` test.\n\n### Fix\n\nReplace the upper\u2011casing logic with a *case\u2011insensitive* comparison that keeps the original casing of the line (so that the data columns are read correctly).  One simple approach is to split the line, lower\u2011case the keyword, and compare that to a list of lower\u2011case command names:\n\n```python\ndef _read_command(line):\n    line = line.strip()\n    if not line:\n        return\n\n    parts = line.split()\n    # e.g. parts = ['read', 'serr', '1', '2']\n    cmd = parts[0].lower()\n    if cmd == 'read' and 'serr' in (p.lower() for p in parts[1:]):\n        # \u2026 process READ SERR\n        ...\n    elif cmd == 'add':\n        ...\n    # add more command handlers here\n    else:\n        raise ValueError(f'Unrecognized QDP line: {line}')\n```\n\nIf you prefer to keep the existing structure, a minimal patch is:\n\n```diff\n-    upper = line.upper()\n-    if upper.startswith('READ SERR'):\n+    # do a case\u2011insensitive check\n+    words = line.split()\n+    if words[:2] == ['read', 'serr'] or words[:2] == ['READ', 'SERR']:\n```\n\n### Verify\n\nAfter applying the patch, the example file\n\n```\nread serr 1 2\n1 0.5 1 0.5\n```\n\nis read correctly:\n\n```python\n>>> from astropy.table import Table\n>>> T = Table.read('test.qdp', format='ascii.qdp')\n>>> T\n<Table row='2' data='| 0.5   1.0  0.5  1.0   0.5  0.0'\n             columns='(lambda, d_ion, C1, C2, %error, <crash>)'>\n```\n\nThe error column (`%error`) is still present.\n\n### Test\n\nAdd a unit test in `tests/test_ascii_qdp.py`:\n\n```python\ndef test_lowercase_commands(tmp_path):\n    txt = \"read serr 1 2\\n1 0.5 1 0.5\\n\"\n    (tmp_path / \"tmp.qdp\").write_text(txt)\n    t = Table.read(tmp_path / \"tmp.qdp\", format=\"ascii.qdp\")\n    assert \"error\" in t.colnames\n```\n\nRunning `pytest` should now pass.\n\n---\n\n**Bottom line:** Normalize the command line only for matching, not for the rest of the parsing logic.  Converting to lower\u2011case during comparison is enough to make the `ascii.qdp` format case\u2011insensitive while keeping the original data untouched."
    }
  ]
}