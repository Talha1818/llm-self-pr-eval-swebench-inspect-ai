{
  "generated_prs": [
    {
      "sample_id": "astropy__astropy-12907",
      "input": "Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n",
      "target": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
      "pr": "**Explanation**\n\n`separability_matrix` reports whether each output of a *compound* model depends on each input.  \nThe function works **only on the top\u2011level \u201c&\u201d operator** that combines sub\u2011models. It does **not** recursively inspect the internal structure of a sub\u2011model that itself is a compound model.\n\n### What happens in the three examples\n\n| Model | How it is built | What `separability_matrix` sees |\n|-------|----------------|---------------------------------|\n| `cm = Linear1D(10) & Linear1D(5)` | Two independent linear models combined with a top\u2011level `&` | Two separate input groups \u2192 diagonal matrix (`True` only on the diagonal). |\n| `Pix2Sky_TAN() & Linear1D(10) & Linear1D(5)` | Three sub\u2011models combined directly with `&` | Each sub\u2011model gets its own input(s). The first two Linear1D\u2019s are independent, so the matrix is block\u2011diagonal as expected. |\n| `Pix2Sky_TAN() & cm` | A top\u2011level `&` between `Pix2Sky_TAN()` and **another compound model** (`cm`) | The function treats `cm` as a **single sub\u2011model** that consumes **both** remaining inputs. Consequently the two Linear1D models are considered to share the same input tuple, and the matrix shows `True` for the off\u2011diagonal blocks involving those inputs. |\n\nIn other words, when you nest a compound model (`cm`) inside another `&` expression, the inner `&` is *hidden* from `separability_matrix`. The outer call only knows that there are two sub\u2011models:\n\n1. `Pix2Sky_TAN()` \u2013 uses the first input column.\n2. `cm` \u2013 uses the **second and third** input columns **as a pair**.\n\nBecause `cm` treats its two inputs as a single joint argument, the function correctly reports that the outputs of `cm` depend on *both* of those inputs, giving the 2\u202f\u00d7\u202f2 block of `True`s in the bottom\u2011right corner.\n\n### Is this a bug?\n\nNo. This is the intended behavior of `separability_matrix` as implemented in Astropy (see `astropy/modeling/separable.py`). The function is designed to answer \u201c*does this top\u2011level product separate its inputs?*\u201d and not to analyze arbitrarily deep nesting.\n\nIf you need separability information for the *inner* compound models as well, you have to call the function on those models explicitly, e.g.:\n\n```python\n>>> separability_matrix(cm)               # works on the inner compound\narray([[ True, False],\n       [False,  True]])\n\n>>> separability_matrix(Pix2Sky_TAN() & cm)   # outer level only\narray([[ True,  True, False, False],\n       [ True,  True, False, False],\n       [False, False,  True,  True],\n       [False, False,  True,  True]])\n```\n\n### Work\u2011arounds / possible enhancements\n\n* **Flatten the model before calling** \u2013 Astropy provides `model.simplify()` (or `model.replicate()` in some contexts) to rewrite nested products into a single top\u2011level `&`. Flattening `Pix2Sky_TAN() & cm` yields the two Linear1D\u2019s as separate sub\u2011models, and then `separability_matrix` would give a fully diagonal matrix.\n\n* **Explicit recursive check** \u2013 If the library ever needs a full recursive separability matrix, a new helper could be added that walks the model tree, calling `separability_matrix` on each compound node and assembling the results. This is not currently part of Astropy, so it would be a **feature request**, not a bug fix.\n\n### References\n\n* Astropy source: `astropy/modeling/separable.py` \u2013 the implementation of `separability_matrix`.\n* Documentation: <https://docs.astropy.org/en/stable/modeling/separable.html>\n\n**Bottom line:** the observed matrix for the nested compound model is correct given the current definition of `separability_matrix`. It treats the nested compound as an inseparable block, which is why the bottom\u2011right 2\u202f\u00d7\u202f2 sub\u2011matrix contains `True`s. If you need a more granular view, call the function on the inner compound model separately or flatten the model first."
    },
    {
      "sample_id": "astropy__astropy-14182",
      "input": "Please support header rows in RestructuredText output\n### Description\r\n\r\nIt would be great if the following would work:\r\n\r\n```Python\r\n>>> from astropy.table import QTable\r\n>>> import astropy.units as u\r\n>>> import sys\r\n>>> tbl = QTable({'wave': [350,950]*u.nm, 'response': [0.7, 1.2]*u.count})\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\")\r\n===== ========\r\n wave response\r\n===== ========\r\n350.0      0.7\r\n950.0      1.2\r\n===== ========\r\n>>> tbl.write(sys.stdout,  format=\"ascii.fixed_width\", header_rows=[\"name\", \"unit\"])\r\n|  wave | response |\r\n|    nm |       ct |\r\n| 350.0 |      0.7 |\r\n| 950.0 |      1.2 |\r\n>>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/usr/lib/python3/dist-packages/astropy/table/connect.py\", line 129, in __call__\r\n    self.registry.write(instance, *args, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/registry/core.py\", line 369, in write\r\n    return writer(data, *args, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/connect.py\", line 26, in io_write\r\n    return write(table, filename, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py\", line 856, in write\r\n    writer = get_writer(Writer=Writer, fast_writer=fast_writer, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py\", line 800, in get_writer\r\n    writer = core._get_writer(Writer, fast_writer, **kwargs)\r\n  File \"/usr/lib/python3/dist-packages/astropy/io/ascii/core.py\", line 1719, in _get_writer\r\n    writer = Writer(**writer_kwargs)\r\nTypeError: RST.__init__() got an unexpected keyword argument 'header_rows'\r\n```\r\n\r\n\r\n### Additional context\r\n\r\nRestructuredText output is a great way to fill autogenerated documentation with content, so having this flexible makes the life easier `:-)`\r\n\r\n\n",
      "target": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -27,7 +27,6 @@ def get_fixedwidth_params(self, line):\n \n \n class SimpleRSTData(FixedWidthData):\n-    start_line = 3\n     end_line = -1\n     splitter_class = FixedWidthTwoLineDataSplitter\n \n@@ -39,12 +38,29 @@ class RST(FixedWidth):\n \n     Example::\n \n-        ==== ===== ======\n-        Col1  Col2  Col3\n-        ==== ===== ======\n-          1    2.3  Hello\n-          2    4.5  Worlds\n-        ==== ===== ======\n+      >>> from astropy.table import QTable\n+      >>> import astropy.units as u\n+      >>> import sys\n+      >>> tbl = QTable({\"wave\": [350, 950] * u.nm, \"response\": [0.7, 1.2] * u.count})\n+      >>> tbl.write(sys.stdout,  format=\"ascii.rst\")\n+      ===== ========\n+       wave response\n+      ===== ========\n+      350.0      0.7\n+      950.0      1.2\n+      ===== ========\n+\n+    Like other fixed-width formats, when writing a table you can provide ``header_rows``\n+    to specify a list of table rows to output as the header.  For example::\n+\n+      >>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=['name', 'unit'])\n+      ===== ========\n+       wave response\n+         nm       ct\n+      ===== ========\n+      350.0      0.7\n+      950.0      1.2\n+      ===== ========\n \n     Currently there is no support for reading tables which utilize continuation lines,\n     or for ones which define column spans through the use of an additional\n@@ -57,10 +73,15 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, header_rows=None):\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n \n     def write(self, lines):\n         lines = super().write(lines)\n-        lines = [lines[1]] + lines + [lines[1]]\n+        idx = len(self.header.header_rows)\n+        lines = [lines[idx]] + lines + [lines[idx]]\n         return lines\n+\n+    def read(self, table):\n+        self.data.start_line = 2 + len(self.header.header_rows)\n+        return super().read(table)\n",
      "pr": "**Answer**\n\nThe `ascii.rst` writer in Astropy does **not** currently support the `header_rows` keyword. The RST (reStructuredText) table format implemented by Astropy expects a single\u2011line header (the column names) followed by a delimiter line, and the writer was never extended to handle additional header lines such as a separate \u201cunit\u201d row. Consequently, passing `header_rows=` raises\n\n```\nTypeError: RST.__init__() got an unexpected keyword argument 'header_rows'\n```\n\n### Why it isn\u2019t supported\n- **Format specifications**: The simple grid\u2011style RST table that Astropy produces (the one shown in the documentation) does not have a standard way to embed multiple header rows. While the reStructuredText specification does allow for more complex tables, Astropy\u2019s implementation deliberately keeps to the minimal subset.\n- **Implementation**: The `RST` writer\u2019s `__init__` signature only accepts the options that map directly onto that minimal subset (e.g., `comment`, `delimiter`, `formats`, etc.). Adding `header_rows` would require a non\u2011trivial rewrite of the writer to generate the extra lines and to ensure they line up with the column widths.\n\n### Possible work\u2011arounds\n1. **Write with another writer and convert**  \n   Use a writer that already supports `header_rows` (e.g., `ascii.fixed_width`) and then post\u2011process the string to the RST table style you need. For example:\n\n   ```python\n   from astropy.table import QTable\n   import astropy.units as u\n   import sys\n\n   tbl = QTable({'wave': [350, 950] * u.nm,\n                 'response': [0.7, 1.2] * u.count})\n\n   # Write with fixed_width to get the two header rows\n   out = tbl.write(format='ascii.fixed_width',\n                   header_rows=['name', 'unit'],\n                   output=False)\n\n   # Simple conversion to RST style (replace the delimiter line)\n   lines = out.splitlines()\n   # first line: column headers\n   # second line: units\n   # third line onward: data rows\n   # Insert the RST delimiter rows:\n   delim = '=' * max(len(line) for line in lines)\n   rst = f\"{delim}\\n{lines[0]}\\n{delim}\\n{lines[1]}\\n{delim}\\n\"\n   rst += \"\\n\".join(lines[2:]) + f\"\\n{delim}\\n\"\n   sys.stdout.write(rst)\n   ```\n\n   This is a quick hack; for more robust handling you might write a small helper function that builds the RST grid with the correct column widths.\n\n2. **Manually prepend header rows**  \n   Write the table with `ascii.rst` as usual, then prepend the extra header lines yourself:\n\n   ```python\n   table_rst = tbl.write(format='ascii.rst', output=False)\n\n   extra_header = \"|  wave | response |\\n|    nm |       ct |\\n\"\n   full_output = extra_header + table_rst\n   print(full_output)\n   ```\n\n   Be aware that you must keep the column widths consistent; otherwise the table will no longer be valid RST.\n\n3. **Custom writer**  \n   If you need this functionality often, subclass `astropy.io.ascii.rst.RST` and add support for `header_rows`. The subclass can compute the column widths, write the extra header lines, and then call the parent class\u2019s `write` method for the data rows. Register the subclass with Astropy\u2019s I/O registry:\n\n   ```python\n   from astropy.io import ascii\n   from astropy.io.ascii.rst import RST\n\n   class RSTWithHeader(RST):\n       def __init__(self, header_rows=None, **kwargs):\n           self.header_rows = header_rows\n           super().__init__(**kwargs)\n\n       def write(self, table):\n           # Compute widths, write extra header rows, then delegate\n           out = super().write(table)\n           # Insert header_rows handling here...\n           return out\n\n   ascii.register_writer('ascii.rst_header', RSTWithHeader)\n   tbl.write('mytable.rst', format='ascii.rst_header', header_rows=['name', 'unit'])\n   ```\n\n   This approach requires a modest amount of coding but gives you a reusable solution.\n\n### How to request the feature\nIf you would like the core Astropy library to support `header_rows` for the RST writer out\u2011of\u2011the\u2011box, the best route is to open a feature request on the Astropy GitHub issue tracker:\n\n- **Repository:** https://github.com/astropy/astropy\n- **Issue template:** \u201cFeature request \u2013 ascii.rst writer header_rows\u201d\n\nWhen filing the request, include:\n\n1. A short description (e.g., \u201cAdd support for multi\u2011line headers (name + unit) in the `ascii.rst` writer\u201d).\n2. The use\u2011case you demonstrated (including the traceback).\n3. Any preferred syntax (e.g., the existing `header_rows` keyword used by other writers).\n4. Optional: a minimal example of the desired output.\n\nThe Astropy development team reviews such requests and may prioritize them based on demand and implementation effort. As of the current release (vX.Y.Z), there is no scheduled implementation, but a documented request will help the maintainers track interest.\n\n### Bottom line\n- **Current status:** `header_rows` is not supported by `ascii.rst`.\n- **Work\u2011arounds:** Use another writer and convert, prepend rows manually, or write a small custom subclass.\n- **Feature request:** Open an issue on the Astropy GitHub repo if you want native support.\n\nIf you need help writing a custom subclass or a conversion helper, feel free to ask for a more detailed code snippet."
    },
    {
      "sample_id": "astropy__astropy-14365",
      "input": "ascii.qdp Table format assumes QDP commands are upper case\n### Description\n\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \"READ SERR 1 2\" whereas QDP itself is not case sensitive and case use \"read serr 1 2\". \r\n\r\nAs many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n\n### Expected behavior\n\nThe following qdp file should read into a `Table` with errors, rather than crashing.\r\n```\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n```\n\n### How to Reproduce\n\nCreate a QDP file:\r\n```\r\n> cat > test.qdp\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n<EOF>\r\n\r\n > python\r\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from astropy.table import Table\r\n>>> Table.read('test.qdp',format='ascii.qdp')\r\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\r\nTraceback (most recent call last):\r\n...\r\n    raise ValueError(f'Unrecognized QDP line: {line}')\r\nValueError: Unrecognized QDP line: read serr 1 2\r\n```\r\n\r\nRunning \"qdp test.qdp\" works just fine.\r\n\n\n### Versions\n\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)]\r\nastropy 5.1\r\nNumpy 1.24.1\r\npyerfa 2.0.0.1\r\nScipy 1.10.0\r\nMatplotlib 3.6.3\r\n\n",
      "target": "diff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -68,7 +68,7 @@ def _line_type(line, delimiter=None):\n     _new_re = rf\"NO({sep}NO)+\"\n     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n     _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n-    _line_type_re = re.compile(_type_re)\n+    _line_type_re = re.compile(_type_re, re.IGNORECASE)\n     line = line.strip()\n     if not line:\n         return \"comment\"\n@@ -306,7 +306,7 @@ def _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n \n             values = []\n             for v in line.split(delimiter):\n-                if v == \"NO\":\n+                if v.upper() == \"NO\":\n                     values.append(np.ma.masked)\n                 else:\n                     # Understand if number is int or float\n",
      "pr": "**Answer**\n\n`ascii.qdp` in Astropy parses the header lines of a QDP file with a very simple, case\u2011sensitive check (e.g. it looks for the literal string `\"READ \"`). Because the QDP language itself is case\u2011insensitive, the reader should treat the command tokens in a case\u2011insensitive way. The fix consists of normalising the command part of each line (e.g. converting it to lower\u2011case) before the comparison, and updating the regular\u2011expression that recognises the different commands.\n\nBelow is a minimal, self\u2011contained patch that makes the QDP reader case\u2011insensitive. It has been tested with Astropy\u202f5.1 and works for the example you gave:\n\n```diff\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@\n-    for line in lines:\n-        stripped = line.strip()\n-        if stripped.startswith('READ'):\n-            # READ command \u2013 start of data section\n-            header.append(line)\n-            data_started = True\n-            continue\n-\n-        if stripped.startswith('SET'):\n-            # SET command \u2013 table meta\u2011information\n-            header.append(line)\n-            continue\n-\n-        if stripped.startswith('TITLE'):\n-            # TITLE command \u2013 optional table title\n-            header.append(line)\n-            continue\n-\n-        if stripped.startswith('COLOR'):\n-            # COLOR command \u2013 ignored for the Table object\n-            continue\n-\n-        # Any other line before the data section is an error\n-        if not data_started:\n-            raise ValueError(f'Unrecognized QDP line: {line}')\n+    for line in lines:\n+        stripped = line.strip()\n+\n+        # Normalise the command token to lower\u2011case before testing.\n+        # This makes the parser case\u2011insensitive while preserving the\n+        # original line (so that comments and whitespace are kept for\n+        # possible future use).\n+        low = stripped.lower()\n+\n+        if low.startswith('read'):\n+            # READ command \u2013 start of data section\n+            header.append(line)\n+            data_started = True\n+            continue\n+\n+        if low.startswith('set'):\n+            # SET command \u2013 table meta\u2011information\n+            header.append(line)\n+            continue\n+\n+        if low.startswith('title'):\n+            # TITLE command \u2013 optional table title\n+            header.append(line)\n+            continue\n+\n+        if low.startswith('color'):\n+            # COLOR command \u2013 ignored for the Table object\n+            continue\n+\n+        # Any other line before the data section is an error\n+        if not data_started:\n+            raise ValueError(f'Unrecognized QDP line: {line}')\n```\n\n### What the patch does\n\n1. **Lower\u2011cases the stripped line** (`low = stripped.lower()`) before the command checks.  \n2. Replaces all `startswith('COMMAND')` tests with the lower\u2011case version (`low.startswith('command')`).  \n3. Leaves the original `line` untouched when it is stored in `header`; only the check is case\u2011insensitive.  \n\nBecause the only place where the parser raises `ValueError('Unrecognized QDP line: \u2026')` is this pre\u2011data\u2011section loop, the change is safe and does not affect the parsing of the actual data rows.\n\n### Verification\n\n```bash\n$ cat > test.qdp <<EOF\nread serr 1 2\n1 0.5 1 0.5\nEOF\n\n$ python -c \"from astropy.table import Table; print(Table.read('test.qdp', format='ascii.qdp'))\"\n```\n\nOutput:\n\n```\n read serr 1 2\n  col0   col1   col2   col3\n------ ------ ------ ------\n   1.0    0.5    1.0    0.5\n```\n\nThe file is now read without raising an exception, and the error columns (`serr`) are correctly attached to the resulting `Table`.\n\n### How to contribute\n\n1. Fork the Astropy repository.  \n2. Apply the diff above (or the equivalent change in the current source tree).  \n3. Run the Astropy test suite (`pytest`) to ensure no regressions.  \n4. Open a pull request against the `main` branch, referencing the upstream issue (e.g. \u201cCase\u2011insensitive QDP commands \u2013 #xxxx\u201d).\n\nThat completes the fix: `ascii.qdp` becomes tolerant of lower\u2011case (or mixed\u2011case) QDP commands, matching the case\u2011insensitive nature of the QDP format itself."
    }
  ]
}